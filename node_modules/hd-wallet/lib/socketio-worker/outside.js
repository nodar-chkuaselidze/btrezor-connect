"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setLogCommunication = setLogCommunication;
exports.Socket = void 0;

var _stream = require("../utils/stream");

var _deferred = require("../utils/deferred");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var logCommunication = false;

function setLogCommunication() {
  logCommunication = true;
}

var Socket =
/*#__PURE__*/
function () {
  function Socket(workerFactory, endpoint, destroyerOnInit) {
    _classCallCheck(this, Socket);

    _defineProperty(this, "streams", []);

    this.endpoint = endpoint;
    this.socket = new SocketWorkerHandler(workerFactory, destroyerOnInit);
    this._socketInited = this.socket.init(this.endpoint);
    this.destroyerOnInit = destroyerOnInit;
  }

  _createClass(Socket, [{
    key: "send",
    value: function send(message) {
      var _this = this;

      return this._socketInited.then(function () {
        return _this.socket.send(message);
      });
    }
  }, {
    key: "close",
    value: function close() {
      var _this2 = this;

      if (!this.destroyerOnInit.destroyed) {
        this.destroyerOnInit.emit();
      }

      this.streams.forEach(function (stream) {
        return stream.dispose();
      });

      this._socketInited.then(function () {
        _this2.socket.close();
      }, function () {});
    }
  }, {
    key: "observe",
    value: function observe(event) {
      var _this3 = this;

      var res = _stream.Stream.fromPromise(this._socketInited.then(function () {
        return _this3.socket.observe(event);
      }));

      this.streams.push(res);
      return res;
    }
  }, {
    key: "subscribe",
    value: function subscribe(event) {
      var _this4 = this;

      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      return this._socketInited.then(function () {
        var _this4$socket;

        return (_this4$socket = _this4.socket).subscribe.apply(_this4$socket, [event].concat(values));
      })["catch"](function () {});
    }
  }]);

  return Socket;
}();

exports.Socket = Socket;
var errorTypes = ['connect_error', 'reconnect_error', 'error', 'close', 'disconnect'];
var disconnectErrorTypes = ['connect_error', 'reconnect_error', 'close', 'disconnect'];

var SocketWorkerHandler =
/*#__PURE__*/
function () {
  function SocketWorkerHandler(workerFactory, destroyerOnInit) {
    _classCallCheck(this, SocketWorkerHandler);

    _defineProperty(this, "stopped", false);

    _defineProperty(this, "observers", {});

    this.workerFactory = workerFactory;
    this.counter = 0;
    this.destroyerOnInit = destroyerOnInit;
  }

  _createClass(SocketWorkerHandler, [{
    key: "_tryWorker",
    value: function _tryWorker(endpoint, type) {
      var _this5 = this;

      var worker = this.workerFactory();
      var dfd = (0, _deferred.deferred)();
      var destroyed = false;

      var funOnDestroy = function funOnDestroy(n, detach) {
        destroyed = true;
        worker.terminate();
        detach();
      };

      this.destroyerOnInit.attach(funOnDestroy);

      worker.onmessage = function (_ref) {
        var data = _ref.data;

        _this5.destroyerOnInit.detach(funOnDestroy);

        if (typeof data === 'string') {
          var parsed = JSON.parse(data);

          if (parsed.type === 'initDone') {
            dfd.resolve(worker);
          } else {
            if (!destroyed) {
              worker.terminate();
            }

            dfd.reject(new Error('Connection failed.'));
          }
        }
      };

      worker.postMessage(JSON.stringify({
        type: 'init',
        endpoint: endpoint,
        connectionType: type
      }));
      return dfd.promise;
    }
  }, {
    key: "init",
    value: function init(endpoint) {
      var _this6 = this;

      return this._tryWorker(endpoint, 'websocket')["catch"](function () {
        return _this6._tryWorker(endpoint, 'polling');
      }).then(function (worker) {
        var cworker = worker;
        _this6._worker = cworker;
        var emitter = new _stream.Emitter();

        cworker.onmessage = function (_ref2) {
          var data = _ref2.data;

          if (typeof data === 'string') {
            if (!_this6.stopped) {
              emitter.emit(JSON.parse(data));
            }
          }
        };

        _this6._emitter = emitter;
        disconnectErrorTypes.forEach(function (type) {
          _this6.observe(type).map(function () {
            // almost the same as this.close(),
            // but doesn't call destroy()
            // since that would also delete all handlers attached on emitters
            // and we want to observe errors from more places
            _this6._sendMessage({
              type: 'close'
            });

            _this6._emitter = null;
            return null;
          });
        });
      });
    }
  }, {
    key: "close",
    value: function close() {
      var _this7 = this;

      this.stopped = true;

      this._sendMessage({
        type: 'close'
      });

      if (this._emitter != null) {
        this._emitter.destroy();

        this._emitter = null;
      }

      return new Promise(function (resolve) {
        setTimeout(function () {
          if (_this7._worker != null) {
            _this7._worker.terminate();
          }

          resolve();
        }, 10);
      });
    }
  }, {
    key: "send",
    value: function send(imessage) {
      this.counter++;
      var counter = this.counter;

      this._sendMessage({
        type: 'send',
        message: imessage,
        id: counter
      });

      var dfd = (0, _deferred.deferred)();

      if (this._emitter == null) {
        return Promise.reject(new Error('Server disconnected.'));
      }

      this._emitter.attach(function (message, detach) {
        if (logCommunication) {
          console.log('[socket.io] in message', message);
        }

        if (message.type === 'sendReply' && message.id === counter) {
          var _message$reply = message.reply,
              result = _message$reply.result,
              error = _message$reply.error;

          if (error != null) {
            dfd.reject(error);
          } else {
            dfd.resolve(result);
          }

          detach();
        } // This is not covered by coverage, because it's hard to simulate
        // Happens when the server is disconnected during some long operation
        // It's hard to simulate long operation on regtest (very big transactions)
        // but happens in real life


        if (message.type === 'emit' && errorTypes.indexOf(message.event) !== -1) {
          dfd.reject(new Error('Server disconnected.'));
          detach();
        }
      });

      return dfd.promise;
    }
  }, {
    key: "observe",
    value: function observe(event) {
      if (this.observers[event] != null) {
        return this.observers[event];
      }

      var observer = this._newObserve(event);

      this.observers[event] = observer;
      return observer;
    }
  }, {
    key: "_newObserve",
    value: function _newObserve(event) {
      var _this8 = this;

      this.counter++;
      var counter = this.counter;

      this._sendMessage({
        type: 'observe',
        event: event,
        id: counter
      }); // $FlowIssue - this can't be null if used from bitcore.js


      var emitter = this._emitter;

      var r = _stream.Stream.fromEmitter(emitter, function () {
        _this8._sendMessage({
          type: 'unobserve',
          event: event,
          id: counter
        });

        delete _this8.observers[event];
      }).filter(function (message) {
        return message.type === 'emit' && message.event === event;
      }) // $FlowIssue
      .map(function (message) {
        return message.data;
      });

      return r;
    }
  }, {
    key: "subscribe",
    value: function subscribe(event) {
      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        values[_key2 - 1] = arguments[_key2];
      }

      this._sendMessage({
        type: 'subscribe',
        event: event,
        values: values
      });
    }
  }, {
    key: "_sendMessage",
    value: function _sendMessage(message) {
      // $FlowIssue - this can't be null if used from bitcore.js
      var worker = this._worker;

      if (logCommunication) {
        console.log('[socket.io] out message', message);
      }

      worker.postMessage(JSON.stringify(message));
    }
  }]);

  return SocketWorkerHandler;
}();