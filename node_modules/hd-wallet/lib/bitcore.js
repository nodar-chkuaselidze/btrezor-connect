"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BitcoreBlockchain = void 0;

var _utxoLib = require("@trezor/utxo-lib");

var _stream = require("./utils/stream");

var _outside = require("./socketio-worker/outside");

var _deferred = require("./utils/deferred");

var _uniqueRandom = require("./utils/unique-random");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var BitcoreBlockchain =
/*#__PURE__*/
function () {
  _createClass(BitcoreBlockchain, null, [{
    key: "_tryEndpoint",
    // socket errors
    // activity on subscribed addresses
    // subscribed addresses
    // does server support estimatesmartfee
    // don't show errors; on testing
    value: function _tryEndpoint(endpoints, socketWorkerFactory, tried, closeOnInit) {
      var triedCopy = tried;
      var untriedEndpoints = endpoints.filter(function (e, i) {
        return !tried[i.toString()];
      });

      if (untriedEndpoints.length === 0) {
        return Promise.reject(new Error('All backends are down.'));
      }

      var random = (0, _uniqueRandom.uniqueRandom)(untriedEndpoints.length);
      return onlineStatusCheck(socketWorkerFactory, untriedEndpoints[random], closeOnInit).then(function (socket) {
        if (socket) {
          return {
            socket: socket,
            url: untriedEndpoints[random]
          };
        }

        triedCopy[random.toString()] = true;
        return BitcoreBlockchain._tryEndpoint(endpoints, socketWorkerFactory, triedCopy, closeOnInit);
      });
    }
  }]);

  function BitcoreBlockchain(endpoints, socketWorkerFactory) {
    var _this = this;

    var network = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _utxoLib.networks.bitcoin;

    _classCallCheck(this, BitcoreBlockchain);

    _defineProperty(this, "socket", (0, _deferred.deferred)());

    _defineProperty(this, "workingUrl", 'none');

    _defineProperty(this, "_silent", false);

    _defineProperty(this, "closeOnInit", new _stream.Emitter());

    this.addresses = new Set();
    this.socketWorkerFactory = socketWorkerFactory;
    this.endpoints = endpoints;
    this.network = network;

    var lookupTM = function lookupTM(socket) {
      return _stream.Stream.filterError(socket.observe('bitcoind/addresstxid').mapPromise(function (_ref) {
        var txid = _ref.txid;
        return _this.lookupTransaction(txid);
      }));
    };

    var observeBlocks = function observeBlocks(socket) {
      socket.subscribe('bitcoind/hashblock');
      return socket.observe('bitcoind/hashblock');
    };

    var errors = _stream.Stream.setLater();

    var notifications = _stream.Stream.setLater();

    var blocks = _stream.Stream.setLater();

    this.errors = errors.stream;
    this.notifications = notifications.stream;
    this.blocks = blocks.stream;
    var tried = {
      '-1': true
    };

    BitcoreBlockchain._tryEndpoint(endpoints, socketWorkerFactory, tried, this.closeOnInit).then(function (_ref2) {
      var socket = _ref2.socket,
          url = _ref2.url;

      _this.closeOnInit.destroy();

      var trySmartFee = estimateSmartTxFee(socket, 2, false).then(function () {
        _this.hasSmartTxFees = true;
      }, function () {
        _this.hasSmartTxFees = false;
      });
      trySmartFee.then(function () {
        _this.workingUrl = url;

        _this.socket.resolve(socket);

        errors.setter(observeErrors(socket));
        notifications.setter(lookupTM(socket));
        blocks.setter(observeBlocks(socket));
      });
    }, function () {
      errors.setter(_stream.Stream.simple(new Error('All backends are offline.')));

      _this.socket.reject(new Error('All backends are offline.'));

      _this.socket.promise["catch"](function (e) {
        if (!_this._silent) {
          console.error(e);
        }
      });
    });
  } // this creates ANOTHER socket!
  // this is for repeated checks after one failure


  _createClass(BitcoreBlockchain, [{
    key: "hardStatusCheck",
    value: function hardStatusCheck() {
      var newOne = new BitcoreBlockchain(this.endpoints, this.socketWorkerFactory);
      return newOne.socket.promise.then(function () {
        return newOne.destroy().then(function () {
          return true;
        });
      }, function () {
        return newOne.destroy().then(function () {
          return false;
        });
      });
    }
  }, {
    key: "subscribe",
    value: function subscribe(inAddresses) {
      var _this2 = this;

      if (!(inAddresses instanceof Set)) {
        throw new Error('Input not a set of strings.');
      }

      var notString = false;
      inAddresses.forEach(function (address) {
        if (typeof address !== 'string') {
          notString = true;
        }
      });

      if (notString) {
        throw new Error('Input not a set of strings.');
      }

      this.socket.promise.then(function (socket) {
        var newAddresses = _toConsumableArray(inAddresses).filter(function (a) {
          return !_this2.addresses.has(a);
        });

        newAddresses.forEach(function (a) {
          return _this2.addresses.add(a);
        });

        if (newAddresses.length !== 0) {
          for (var i = 0; i < newAddresses.length; i += 20) {
            socket.subscribe('bitcoind/addresstxid', newAddresses.slice(i, i + 20));
          }
        }
      }, function () {});
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this3 = this;

      // give socket 1 second to either resolve or reject
      // if it doesn't happen, just destroy
      var oneSecond = new Promise(function (resolve) {
        return setTimeout(resolve, 1000);
      });
      var inited = this.socket.promise["catch"](function () {});
      var sooner = Promise.race([oneSecond, inited]);
      return sooner.then(function (socket) {
        if (!_this3.closeOnInit.destroyed) {
          _this3.closeOnInit.emit();
        }

        _this3.errors.dispose();

        _this3.notifications.dispose();

        _this3.blocks.dispose();

        if (socket != null) {
          return socket.close();
        }

        return Promise.resolve();
      });
    } // start/end are the block numbers, inclusive.
    // start is BIGGER than end
    // anti-intuitive, but the same as bitcore API

  }, {
    key: "lookupTransactionsStream",
    value: function lookupTransactionsStream(addresses, start, end) {
      var _this4 = this;

      var res = _stream.Stream.fromPromise(this.socket.promise.then(function (socket) {
        return lookupAllAddressHistories(socket, addresses, start, end).map(function (r) {
          if (r instanceof Error) {
            return r;
          }

          return r.items.map(function (i) {
            return convertTx(i.tx, _this4.network);
          });
        });
      }));

      return res;
    } // start/end are the block numbers, inclusive.
    // start is BIGGER than end
    // anti-intuitive, but the same as bitcore API

  }, {
    key: "lookupTransactions",
    value: function lookupTransactions(addresses, start, end) {
      var maybeRes = this.lookupTransactionsStream(addresses, start, end).reduce(function (previous, current) {
        if (previous instanceof Error) {
          return previous;
        }

        if (current instanceof Error) {
          return current;
        }

        return previous.concat(current);
      }, []);
      return maybeRes.then(function (maybeArray) {
        if (maybeArray instanceof Error) {
          throw maybeArray;
        }

        return maybeArray;
      });
    }
  }, {
    key: "lookupTransactionsIds",
    value: function lookupTransactionsIds(addresses, start, end) {
      return this.socket.promise.then(function (socket) {
        return Promise.all([lookupTransactionsIdsMempool(socket, addresses, true, start, end), lookupTransactionsIdsMempool(socket, addresses, false, start, end)]);
      }).then(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            a = _ref4[0],
            b = _ref4[1];

        return a.concat(b);
      });
    }
  }, {
    key: "lookupTransaction",
    value: function lookupTransaction(hash) {
      var _this5 = this;

      return this.socket.promise.then(function (socket) {
        return lookupDetailedTransaction(socket, hash).then(function (i) {
          return convertTx(i, _this5.network);
        });
      });
    }
  }, {
    key: "sendTransaction",
    value: function sendTransaction(hex) {
      return this.socket.promise.then(function (socket) {
        return _sendTransaction(socket, hex);
      });
    }
  }, {
    key: "lookupBlockHash",
    value: function lookupBlockHash(height) {
      return this.socket.promise.then(function (socket) {
        return _lookupBlockHash(socket, height);
      });
    }
  }, {
    key: "lookupSyncStatus",
    value: function lookupSyncStatus() {
      return this.socket.promise.then(function (socket) {
        return _lookupSyncStatus(socket);
      });
    }
  }, {
    key: "estimateSmartTxFees",
    value: function estimateSmartTxFees(blocks, conservative) {
      var _this6 = this;

      return this.socket.promise.then(function (socket) {
        var res = Promise.resolve({});
        blocks.forEach(function (block) {
          res = res.then(function (previous) {
            var feePromise = _this6.hasSmartTxFees ? estimateSmartTxFee(socket, block, conservative) : Promise.resolve('-1');
            return feePromise.then(function (fee) {
              var previousCopy = previous;
              previousCopy[block] = fee.toString();
              return previousCopy;
            });
          });
        });
        return res;
      });
    }
  }, {
    key: "estimateTxFees",
    value: function estimateTxFees(blocks, skipMissing) {
      return this.socket.promise.then(function (socket) {
        var res = Promise.resolve({});
        blocks.forEach(function (block) {
          res = res.then(function (p) {
            return estimateTxFee(socket, block).then(function (fee) {
              var previousCopy = p;
              var add = skipMissing ? fee !== -1 : true;

              if (add) {
                previousCopy[block] = fee.toString();
              }

              return previousCopy;
            });
          });
        });
        return res;
      });
    }
  }]);

  return BitcoreBlockchain;
}();

exports.BitcoreBlockchain = BitcoreBlockchain;

function lookupAllAddressHistories(socket, addresses, start, end) {
  return _stream.Stream.combineFlat([lookupAddressHistoriesMempool(socket, addresses, true, start, end), lookupAddressHistoriesMempool(socket, addresses, false, start, end)]);
}

function lookupAddressHistoriesMempool(socket, addresses, mempool, start, end) {
  var initial = {
    from: 0,
    to: 0,
    items: [],
    totalCount: 0
  };
  var pageLength = 1;
  var first = true;
  return _stream.Stream.generate(initial, function (previous) {
    // increasing the page size * 5, but only if the txs are small enough
    // (some users like to have giant transactions,
    // which causes trouble on both network and memory)
    //
    // * 5 is quite aggressive, but in reality, the transactions are either
    // all normal, <500 B (so 5 transactions is probably even maybe too cautious),
    // or are all giant (> 20 kB) so taking by 1 is the best
    var previousTxLength = previous.items.reduce(function (total, history) {
      return total + history.tx.hex.length / 2;
    }, 0);

    if (previousTxLength <= 5000 && !first) {
      pageLength *= 5;
      pageLength = Math.min(50, pageLength);
    }

    first = false;
    var from = previous.to;
    var to = previous.to + pageLength;
    return lookupAddressHistories(socket, addresses, from, to, mempool, start, end).then(function (result) {
      return _objectSpread({}, result, {
        from: from,
        to: to
      });
    });
  }, function (state) {
    return state.to < state.totalCount;
  });
}

function lookupTransactionsIdsMempool(socket, addresses, mempool, start, // recent block height (inclusive)
end) {
  var method = 'getAddressTxids';
  var rangeParam = mempool ? {
    start: start,
    end: end,
    queryMempoolOnly: true
  } : {
    start: start,
    end: end,
    queryMempool: false
  };
  var params = [addresses, rangeParam];
  return socket.send({
    method: method,
    params: params
  });
}

function lookupAddressHistories(socket, addresses, from, // pagination from index (inclusive)
to, // pagination to index (not inclusive)
mempool, start, // recent block height (inclusive)
end) {
  var method = 'getAddressHistory';
  var rangeParam = mempool ? {
    start: start,
    // needed for older bitcores (so we don't load all history if bitcore-node < 3.1.3)
    end: end,
    queryMempoolOnly: true
  } : {
    start: start,
    end: end,
    queryMempol: false
  };
  var params = [addresses, _objectSpread({}, rangeParam, {
    from: from,
    to: to
  })];
  return socket.send({
    method: method,
    params: params
  });
} // https://github.com/bitpay/bitcore-node/issues/423


function lookupDetailedTransaction(socket, hash) {
  var method = 'getDetailedTransaction';
  var params = [hash];
  return socket.send({
    method: method,
    params: params
  });
}

function _sendTransaction(socket, hex) {
  var method = 'sendTransaction';
  var params = [hex];
  return socket.send({
    method: method,
    params: params
  });
}

function _lookupBlockHash(socket, height) {
  var method = 'getBlockHeader';
  var params = [height];
  return socket.send({
    method: method,
    params: params
  }).then(function (res) {
    return res.hash;
  });
}

function _lookupSyncStatus(socket) {
  var method = 'getInfo';
  var params = [];
  return socket.send({
    method: method,
    params: params
  }).then(function (res) {
    return {
      height: res.blocks
    };
  });
}

function estimateSmartTxFee(socket, blocks, conservative) {
  var method = 'estimateSmartFee';
  var params = [blocks, conservative];
  return socket.send({
    method: method,
    params: params
  });
}

function estimateTxFee(socket, blocks) {
  var method = 'estimateFee';
  var params = [blocks];
  return socket.send({
    method: method,
    params: params
  });
}

function onlineStatusCheck(socketWorkerFactory, endpoint, closeOnInit) {
  var socket = new _outside.Socket(socketWorkerFactory, endpoint, closeOnInit);
  var conn = new Promise(function (resolve) {
    observeErrors(socket).awaitFirst().then(function () {
      resolve(false);
    }); // we try to get the first block
    // if it returns something, it probably works

    Promise.race([new Promise(function (tresolve, reject) {
      return setTimeout(function () {
        return reject();
      }, 30000);
    }), _lookupBlockHash(socket, 0)]).then(function () {
      resolve(true);
    }, function () {
      resolve(false);
    });
  });
  return conn.then(function (res) {
    if (!res) {
      socket.close();
      return null;
    }

    return socket;
  });
}

function observeErrors(socket) {
  var errortypes = ['connect_error', 'reconnect_error', 'error', 'close', 'disconnect'];
  var streams = errortypes.map(function (type) {
    var subs = socket.observe(type);
    var cleaned = subs.map(function (k) {
      var stringify = JSON.stringify(k);
      return new Error("".concat(stringify !== undefined ? stringify : 'undefined', " (").concat(type, ")"));
    });
    return cleaned;
  });

  var s = _stream.Stream.combineFlat(streams);

  return s;
}

function convertTx(bcTx, network) {
  return {
    network: network,
    hex: bcTx.hex,
    height: bcTx.height === -1 ? null : bcTx.height,
    timestamp: bcTx.blockTimestamp == null ? null : bcTx.blockTimestamp,
    time: bcTx.time,
    // capricoin specific field
    hash: bcTx.hash,
    inputAddresses: bcTx.inputs.map(function (input) {
      return input.address;
    }),
    outputAddresses: bcTx.outputs.map(function (output) {
      return output.address;
    }),
    vsize: bcTx.size == null ? bcTx.hex.length / 2 : bcTx.size,
    rawTx: bcTx
  };
}