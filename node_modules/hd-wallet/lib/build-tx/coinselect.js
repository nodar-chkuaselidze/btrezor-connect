"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.coinselect = coinselect;

var _utxoLib = require("@trezor/utxo-lib");

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _split = _interopRequireDefault(require("./coinselect-lib/outputs/split"));

var _coinselectLib = _interopRequireDefault(require("./coinselect-lib"));

var _utils = require("./coinselect-lib/utils");

var request = _interopRequireWildcard(require("./request"));

var _bchaddr = require("../utils/bchaddr");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SEGWIT_INPUT_SCRIPT_LENGTH = 51; // actually 50.25, but let's make extra room

var INPUT_SCRIPT_LENGTH = 109;
var P2PKH_OUTPUT_SCRIPT_LENGTH = 25;
var P2SH_OUTPUT_SCRIPT_LENGTH = 23;
var P2WPKH_OUTPUT_SCRIPT_LENGTH = 22;
var P2WSH_OUTPUT_SCRIPT_LENGTH = 34;

function coinselect(utxos, rOutputs, height, feeRate, segwit, countMax, countMaxId, dustThreshold, network) {
  var inputs = convertInputs(utxos, height, segwit);
  var outputs = convertOutputs(rOutputs, network);
  var options = {
    inputLength: segwit ? SEGWIT_INPUT_SCRIPT_LENGTH : INPUT_SCRIPT_LENGTH,
    changeOutputLength: segwit ? P2SH_OUTPUT_SCRIPT_LENGTH : P2PKH_OUTPUT_SCRIPT_LENGTH,
    dustThreshold: dustThreshold
  };
  var algorithm = countMax ? _split["default"] : _coinselectLib["default"];
  var result = algorithm(inputs, outputs, feeRate, options);

  if (!result.inputs) {
    return {
      type: 'false'
    };
  }

  var fee = result.fee;
  var max = countMaxId === -1 ? -1 : result.outputs[countMaxId].value;
  var totalSpent = result.outputs.filter(function (output, i) {
    return i !== rOutputs.length;
  }).map(function (o) {
    return o.value;
  }).reduce(function (a, b) {
    return new _bignumber["default"](a).plus(b);
  }, new _bignumber["default"](0)).plus(new _bignumber["default"](result.fee));
  var allSize = (0, _utils.transactionBytes)(result.inputs, result.outputs); // javascript WTF: fee is a string, allSize is a number, therefore it's working

  var feePerByte = fee / allSize;
  return {
    type: 'true',
    result: _objectSpread({}, result, {
      fee: result.fee.toString(),
      feePerByte: feePerByte.toString(),
      bytes: allSize,
      max: max,
      totalSpent: totalSpent.toString()
    })
  };
}

function convertInputs(inputs, height, segwit) {
  var bytesPerInput = segwit ? SEGWIT_INPUT_SCRIPT_LENGTH : INPUT_SCRIPT_LENGTH;
  return inputs.map(function (input, i) {
    return {
      id: i,
      script: {
        length: bytesPerInput
      },
      value: input.value,
      own: input.own,
      coinbase: input.coinbase,
      confirmations: input.height == null ? 0 : 1 + height - input.height
    };
  });
}

function isBech32(address) {
  try {
    _utxoLib.address.fromBech32(address);

    return true;
  } catch (e) {
    return false;
  }
}

function getScriptAddress(address, network) {
  var bech = isBech32(address);
  var pubkeyhash;

  if (!bech) {
    var decoded = _utxoLib.address.fromBase58Check((0, _bchaddr.convertCashAddress)(address));

    pubkeyhash = decoded.version === network.pubKeyHash;
  } else {
    var _decoded = _utxoLib.address.fromBech32(address);

    pubkeyhash = _decoded.data.length === 20;
  }

  var becLength = pubkeyhash ? P2WPKH_OUTPUT_SCRIPT_LENGTH : P2WSH_OUTPUT_SCRIPT_LENGTH;
  var norLength = pubkeyhash ? P2PKH_OUTPUT_SCRIPT_LENGTH : P2SH_OUTPUT_SCRIPT_LENGTH;
  var length = bech ? becLength : norLength;
  return {
    length: length
  };
}

function convertOutputs(outputs, network) {
  // most scripts are P2PKH; default is P2PKH
  var defaultScript = {
    length: P2PKH_OUTPUT_SCRIPT_LENGTH
  };
  return outputs.map(function (output) {
    if (output.type === 'complete') {
      return {
        value: output.amount,
        script: getScriptAddress(output.address, network)
      };
    }

    if (output.type === 'noaddress') {
      return {
        value: output.amount,
        script: defaultScript
      };
    }

    if (output.type === 'opreturn') {
      return {
        value: '0',
        script: {
          length: 2 + output.dataHex.length / 2
        }
      };
    }

    if (output.type === 'send-max') {
      return {
        script: getScriptAddress(output.address, network)
      };
    }

    if (output.type === 'send-max-noaddress') {
      return {
        script: defaultScript
      };
    }

    throw new Error('WRONG-OUTPUT-TYPE');
  });
}