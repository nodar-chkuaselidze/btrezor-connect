"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = branchAndBound;

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var utils = _interopRequireWildcard(require("../utils"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var maxTries = 1000000;

function calculateEffectiveValues(utxos, feeRate) {
  return utxos.map(function (utxo) {
    var value = utils.bignumberOrNaN(utxo.value);

    if (value.isNaN()) {
      return {
        utxo: utxo,
        effectiveValue: new _bignumber["default"](0)
      };
    }

    var effectiveFee = utils.inputBytes(utxo) * feeRate;
    var effectiveValue = value.minus(effectiveFee);
    return {
      utxo: utxo,
      effectiveValue: effectiveValue
    };
  });
}

function branchAndBound(factor) {
  return function (utxos, outputs, feeRate, options) {
    var inputLength = options.inputLength,
        changeOutputLength = options.changeOutputLength,
        explicitDustThreshold = options.dustThreshold;
    var feeRateBigInt = utils.bignumberOrNaN(feeRate);
    if (feeRateBigInt.isNaN() || !feeRateBigInt.isInteger()) return {};
    var feeRateNumber = feeRateBigInt.toNumber();
    var costPerChangeOutput = utils.outputBytes({
      script: {
        length: changeOutputLength
      }
    }) * feeRateNumber;
    var costPerInput = utils.inputBytes({
      script: {
        length: inputLength
      }
    }) * feeRateNumber;
    var costOfChange = Math.floor((costPerInput + costPerChangeOutput) * factor);
    var txBytes = utils.transactionBytes([], outputs);
    var bytesAndFee = feeRateBigInt.times(txBytes);
    var outSum = utils.sumOrNaN(outputs);

    if (outSum.isNaN()) {
      return {
        fee: '0'
      };
    }

    var outAccum = outSum.plus(bytesAndFee);
    var effectiveUtxos = calculateEffectiveValues(utxos, feeRateNumber).filter(function (x) {
      return x.effectiveValue.comparedTo(new _bignumber["default"](0)) > 0;
    }).sort(function (a, b) {
      var subtract = b.effectiveValue.minus(a.effectiveValue).toNumber();

      if (subtract !== 0) {
        return subtract;
      }

      return a.utxo.i - b.utxo.i;
    });
    var selected = search(effectiveUtxos, outAccum, costOfChange);

    if (selected !== null) {
      var inputs = [];

      for (var i = 0; i < effectiveUtxos.length; i++) {
        if (selected[i]) {
          inputs.push(effectiveUtxos[i].utxo);
        }
      }

      return utils.finalize(inputs, outputs, feeRateNumber, inputLength, changeOutputLength, explicitDustThreshold);
    }

    return {
      fee: '0'
    };
  };
} // Depth first search
// Inclusion branch first (Largest First Exploration), then exclusion branch


function search(effectiveUtxos, target, costOfChange) {
  if (effectiveUtxos.length === 0) {
    return null;
  }

  var tries = maxTries;
  var selected = []; // true -> select the utxo at this index

  var selectedAccum = new _bignumber["default"](0); // sum of effective values

  var done = false;
  var backtrack = false;
  var remaining = effectiveUtxos.reduce(function (a, x) {
    return x.effectiveValue.plus(a);
  }, new _bignumber["default"](0));
  var costRange = target.plus(costOfChange);
  var depth = 0;

  while (!done) {
    if (tries <= 0) {
      // Too many tries, exit
      return null;
    }

    if (selectedAccum.comparedTo(costRange) > 0) {
      // Selected value is out of range, go back and try other branch
      backtrack = true;
    } else if (selectedAccum.comparedTo(target) >= 0) {
      // Selected value is within range
      done = true;
    } else if (depth >= effectiveUtxos.length) {
      // Reached a leaf node, no solution here
      backtrack = true;
    } else if (selectedAccum.plus(remaining).comparedTo(target) < 0) {
      // Cannot possibly reach target with amount remaining
      if (depth === 0) {
        // At the first utxo, no possible selections, so exit
        return null;
      }

      backtrack = true;
    } else {
      // Continue down this branch
      // Remove this utxo from the remaining utxo amount
      remaining = remaining.minus(effectiveUtxos[depth].effectiveValue); // Inclusion branch first (Largest First Exploration)

      selected[depth] = true;
      selectedAccum = selectedAccum.plus(effectiveUtxos[depth].effectiveValue);
      depth++;
    } // Step back to the previous utxo and try the other branch


    if (backtrack) {
      backtrack = false; // Reset

      depth--; // Walk backwards to find the first utxo which has not has its second branch traversed

      while (!selected[depth]) {
        remaining = remaining.plus(effectiveUtxos[depth].effectiveValue); // Step back one

        depth--;

        if (depth < 0) {
          // We have walked back to the first utxo
          // and no branch is untraversed. No solution, exit.
          return null;
        }
      } // Now traverse the second branch of the utxo we have arrived at.


      selected[depth] = false;
      selectedAccum = selectedAccum.minus(effectiveUtxos[depth].effectiveValue);
      depth++;
    }

    tries--;
  }

  return selected;
}