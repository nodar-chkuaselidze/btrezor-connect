"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inputBytes = inputBytes;
exports.outputBytes = outputBytes;
exports.dustThreshold = dustThreshold;
exports.transactionBytes = transactionBytes;
exports.uintOrNaN = uintOrNaN;
exports.bignumberOrNaN = bignumberOrNaN;
exports.sumOrNaN = sumOrNaN;
exports.finalize = finalize;
exports.anyOf = anyOf;
exports.utxoScore = utxoScore;

var _bignumber = _interopRequireDefault(require("bignumber.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// baseline estimates, used to improve performance
var TX_EMPTY_SIZE = 4 + 1 + 1 + 4 + 1; // 8 bytes start, 2 times 1 byte count in/out, 1 extra byte for segwit start

var TX_INPUT_BASE = 32 + 4 + 1 + 4;
var TX_OUTPUT_BASE = 8 + 1;

function inputBytes(input) {
  if (input.script.length == null) {
    throw new Error('Null script length');
  }

  return TX_INPUT_BASE + input.script.length;
}

function outputBytes(output) {
  if (output.script.length == null) {
    throw new Error('Null script length');
  }

  return TX_OUTPUT_BASE + output.script.length;
}

function dustThreshold(feeRate, inputLength, outputLength, explicitDustThreshold) {
  var size = transactionBytes([{
    script: {
      length: inputLength
    }
  }], [{
    script: {
      length: outputLength
    }
  }]);
  var price = size * feeRate;
  var threshold = Math.max(explicitDustThreshold, price);
  return threshold;
}

function transactionBytes(inputs, outputs) {
  return TX_EMPTY_SIZE + inputs.reduce(function (a, x) {
    return a + inputBytes(x);
  }, 0) + outputs.reduce(function (a, x) {
    return a + outputBytes(x);
  }, 0);
}

function uintOrNaN(v) {
  if (typeof v !== 'number') return NaN;
  if (!Number.isFinite(v)) return NaN;
  if (Math.floor(v) !== v) return NaN;
  if (v < 0) return NaN;
  return v;
}

function bignumberOrNaN(v) {
  if (v instanceof _bignumber["default"]) return v;
  if (typeof v !== 'string') return new _bignumber["default"](NaN);

  try {
    var value = new _bignumber["default"](v);
    return value.toFixed() === v && value.isInteger() ? value : new _bignumber["default"](NaN);
  } catch (error) {
    return new _bignumber["default"](NaN);
  }
}

function sumOrNaN(range) {
  var forgiving = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return range.reduce(function (a, x) {
    if (Number.isNaN(a)) return new _bignumber["default"](NaN);
    var value = bignumberOrNaN(x.value);
    if (value.isNaN()) return forgiving ? new _bignumber["default"](0).plus(a) : new _bignumber["default"](NaN);
    return value.plus(a);
  }, new _bignumber["default"](0));
}

function finalize(inputs, outputsO, feeRate, inputLength, changeOutputLength, explicitDustThreshold) {
  var outputs = outputsO;
  var bytesAccum = transactionBytes(inputs, outputs);
  var blankOutputBytes = outputBytes({
    script: {
      length: changeOutputLength
    }
  });
  var feeAfterExtraOutput = new _bignumber["default"](feeRate * (bytesAccum + blankOutputBytes));
  var sumInputs = sumOrNaN(inputs);
  var sumOutputs = sumOrNaN(outputs);
  var sumIsNotNaN = !sumInputs.isNaN() && !sumOutputs.isNaN();
  var remainderAfterExtraOutput = sumIsNotNaN ? sumOrNaN(inputs).minus(sumOrNaN(outputs).plus(feeAfterExtraOutput)) : new _bignumber["default"](0);
  var dust = dustThreshold(feeRate, inputLength, changeOutputLength, explicitDustThreshold); // is it worth a change output?

  if (remainderAfterExtraOutput.comparedTo(new _bignumber["default"](dust)) > 0) {
    outputs = outputs.concat({
      value: remainderAfterExtraOutput.toString(),
      script: {
        length: changeOutputLength
      }
    });
  }

  if (!sumIsNotNaN) return {
    fee: (feeRate * bytesAccum).toString()
  };
  var fee = sumOrNaN(inputs).minus(sumOrNaN(outputs)).toString();
  return {
    inputs: inputs,
    outputs: outputs,
    fee: fee
  };
}

function anyOf(algorithms) {
  return function (utxos, outputs, feeRate, inputLength, outputLength) {
    var result = {
      fee: Infinity
    };

    for (var i = 0; i < algorithms.length; i++) {
      var algorithm = algorithms[i];
      result = algorithm(utxos, outputs, feeRate, inputLength, outputLength);

      if (result.inputs) {
        return result;
      }
    }

    return result;
  };
}

function utxoScore(x, feeRate) {
  return new _bignumber["default"](x.value).minus(new _bignumber["default"](feeRate * inputBytes(x)));
}