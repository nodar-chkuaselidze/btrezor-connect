"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StreamWithEnding = exports.Stream = exports.Emitter = void 0;

var _deferred = require("./deferred");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// making sure that Error from a promise is an Error object
function formatError(error) {
  if (_typeof(error) === 'object' && error != null && error instanceof Error) {
    return error;
  }

  if (_typeof(error) === 'object' && error != null && error.message != null) {
    return new Error(error.message);
  }

  return new Error(JSON.stringify(error));
} // having detach function in the handler is actually very useful
// because we don't have to name the function when attaching emitter


// const MAX_LISTENERS = 50;
var Emitter =
/*#__PURE__*/
function () {
  function Emitter() {
    _classCallCheck(this, Emitter);

    _defineProperty(this, "listeners", []);

    _defineProperty(this, "destroyed", false);
  }

  _createClass(Emitter, [{
    key: "destroy",
    value: function destroy() {
      var _this = this;

      this.listeners.forEach(function (handler) {
        return _this.detach(handler);
      });
      this.listeners = [];
      this.destroyed = true;
    } // `attach` doesn't affect currently running `emit`, so listeners are not
    // modified in place.

  }, {
    key: "attach",
    value: function attach(handler) {
      if (this.destroyed) {
        throw new Error('Attaching on a destroyed emitter');
      } // this is to prevent possible unintended effects
      // (not necessary, remove if you REALLY need to do this)


      this.listeners.forEach(function (oldHandler) {
        if (oldHandler === handler) {
          throw new Error('Cannot attach the same listener twice');
        }
      });
      this.listeners.push(handler);
    }
  }, {
    key: "detach",
    value: function detach(handler) {
      // if destroyed => let it be, let it be
      this.listeners = this.listeners.filter(function (listener) {
        if (listener === handler) {
          return false;
        }

        return true;
      });
    }
  }, {
    key: "emit",
    value: function emit(value) {
      var _this2 = this;

      if (this.destroyed) {
        // if destroyed -> not really throwing error (nothing bad happens), just warn
        console.warn(new Error('Emitting on a destroyed emitter'));
      }

      this.listeners.forEach(function (listener) {
        listener(value, function () {
          _this2.detach(listener);
        });
      });
    }
  }]);

  return Emitter;
}();

exports.Emitter = Emitter;

var Stream =
/*#__PURE__*/
function () {
  _createClass(Stream, null, [{
    key: "fromEmitter",
    // note that this never "finishes"
    // note that dispose does NOT destroy the emitter
    value: function fromEmitter(emitter, dispose) {
      return new Stream(function (update) {
        var disposed = false;

        var handler = function handler(t) {
          // check for disposed not needed, handler is removed
          update(t);
        };

        emitter.attach(handler);
        return function () {
          if (!disposed) {
            disposed = true;
            emitter.detach(handler);
            dispose();
          }
        };
      });
    }
  }, {
    key: "fromEmitterFinish",
    value: function fromEmitterFinish(emitter, finisher, dispose) {
      return new Stream(function (update, finish) {
        var disposed = false;

        var handler = function handler(t) {
          update(t);
        };

        emitter.attach(handler);

        var finishHandler = function finishHandler(nothing, detach) {
          finish();
          detach();
          emitter.detach(handler);
        };

        finisher.attach(finishHandler);
        return function () {
          // TODO - this is why dispose does not make much sense
          // should dispose() be called when finish() has been called? or no?
          // I want to get rid of dispose eventually
          if (!disposed) {
            disposed = true;
            emitter.detach(handler);
            finisher.detach(finishHandler);
            dispose();
          }
        };
      });
    }
  }, {
    key: "empty",
    value: function empty() {
      return new Stream(function (update, finish) {
        var disposed = false;
        setTimeout(function () {
          if (!disposed) {
            finish();
          }
        }, 0);
        return function () {
          disposed = true;
        };
      });
    }
  }, {
    key: "fromPromise",
    value: function fromPromise(promise, ignoreRejectionError) {
      var _ignoreRejectionError = ignoreRejectionError == null ? false : ignoreRejectionError;

      var nstream = new Stream(function (update, finish) {
        var stream_;
        var disposed = false;
        promise.then(function (stream) {
          if (!disposed) {
            if (!stream.disposed) {
              stream.values.attach(function (v) {
                return update(v);
              });
              stream.finish.attach(function () {
                return finish();
              });
              stream_ = stream;
            } else {// uhhh I donno
            }
          }
        }, function (error) {
          if (!disposed) {
            if (!_ignoreRejectionError) {
              update(formatError(error));
            }

            setTimeout(function () {
              if (!disposed) {
                finish();
              }
            }, 10);
          }
        });
        return function () {
          disposed = true;

          if (stream_ != null) {
            stream_.dispose();
          }
        };
      });
      return nstream;
    }
  }, {
    key: "setLater",
    value: function setLater() {
      var df = (0, _deferred.deferred)();
      var set = false;

      var setter = function setter(s) {
        if (set) {
          throw new Error('Setting stream twice.');
        }

        set = true;
        df.resolve(s);
      }; // $FlowIssue the promise is never rejected, so the type can be Stream<T>


      var stream = Stream.fromPromise(df.promise);
      return {
        stream: stream,
        setter: setter
      };
    } // note - when generate() ends with error,
    // the stream emits the error as a value and then finishes
    // note - condition is for CONTINUING
    // the last value will always NOT satisfy the condition

  }, {
    key: "generate",
    value: function generate(initial, _generate, condition) {
      return new Stream(function (update, finish) {
        var disposed = false;

        var iterate = function iterate(state) {
          var promise;

          try {
            // catch error in generate, if it happens
            promise = _generate(state);
          } catch (error) {
            if (disposed) {// stop the iteration
            } else {
              update(formatError(error));
              finish();
            }

            return;
          }

          promise.then(function (nstate) {
            if (disposed) {// stop the iteration
            } else {
              update(nstate);

              if (condition(nstate)) {
                iterate(nstate);
              } else {
                finish();
              }
            }
          }, function (error) {
            if (disposed) {// stop the iteration
            } else {
              update(formatError(error));
              finish();
            }
          });
        };

        setTimeout(function () {
          return iterate(initial);
        }, 1);
        return function () {
          disposed = true;
        };
      });
    }
  }, {
    key: "simple",
    value: function simple(value) {
      var values = new Emitter();
      var finish = new Emitter();
      var stream = Stream.fromEmitterFinish(values, finish, function () {});
      setTimeout(function () {
        values.emit(value);
        setTimeout(function () {
          finish.emit();
        }, 1);
      }, 1);
      return stream;
    }
  }, {
    key: "combineFlat",
    value: function combineFlat(streams) {
      if (streams.length === 0) {
        return Stream.empty();
      }

      return new Stream(function (update, finish) {
        var finished = new Set();
        streams.forEach(function (s, i) {
          s.values.attach(function (v) {
            update(v);
          });
          s.finish.attach(function () {
            finished.add(i);

            if (finished.size >= streams.length) {
              finish();
            }
          });
        });
        return function () {
          streams.forEach(function (s) {
            return s.dispose();
          });
        };
      });
    }
  }, {
    key: "filterError",
    value: function filterError(stream) {
      var res_ = stream.filter(function (v) {
        return !(v instanceof Error);
      }); // $FlowIssue

      var res = res_;
      return res;
    }
  }]);

  function Stream(controller) {
    var _this3 = this;

    _classCallCheck(this, Stream);

    _defineProperty(this, "disposed", false);

    this.values = new Emitter();
    this.finish = new Emitter();
    var controllerDispose = controller(function (value) {
      _this3.values.emit(value);
    }, function () {
      _this3.finish.emit();
    });

    this.dispose = function () {
      controllerDispose();

      _this3.values.destroy();

      _this3.finish.destroy();

      _this3.disposed = true;
    };
  }

  _createClass(Stream, [{
    key: "awaitFirst",
    value: function awaitFirst() {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        /* istanbul ignore next */
        var _onFinish = function onFinish() {};

        var onValue = function onValue(value) {
          _this4.values.detach(onValue);

          _this4.finish.detach(_onFinish);

          resolve(value);
        };

        _onFinish = function onFinish() {
          _this4.values.detach(onValue);

          _this4.finish.detach(_onFinish);

          reject(new Error('No first value.'));
        };

        _this4.values.attach(onValue);

        _this4.finish.attach(_onFinish);
      });
    }
  }, {
    key: "awaitFinish",
    value: function awaitFinish() {
      var _this5 = this;

      return new Promise(function (resolve) {
        _this5.finish.attach(function (nothing, detach) {
          detach();
          resolve();
        });
      });
    }
  }, {
    key: "map",
    value: function map(fn) {
      var _this6 = this;

      return new Stream(function (update, finish) {
        _this6.values.attach(function (value) {
          update(fn(value));
        });

        _this6.finish.attach(finish);

        return _this6.dispose;
      });
    } // note: this DOES keep the order
    // note: it does not finish on rejected promise or error in fn
    //       it just emits error and does the next
    // note: even when it does keep order, functions are run as soon as the values come,
    //       but the values are emitted in the same order, no matter how long do the promise takes
    //       so you can depend on RESULT order being the same, but there can be more promises
    //       running at the same time
    // note: calling dispose IMMEDIATELY stops the streaming values

  }, {
    key: "mapPromise",
    value: function mapPromise(fn) {
      var _this7 = this;

      return new Stream(function (update, finish) {
        var previous = Promise.resolve();
        var disposed = false;

        _this7.values.attach(function (value) {
          var previousNow = previous; // Flow idiocy

          var runFn = function () {
            try {
              return fn(value);
            } catch (e) {
              return Promise.reject(e);
            }
          }();

          previous = runFn.then(function (u) {
            return previousNow.then(function () {
              if (!disposed) {
                update(u);
              }
            });
          }, function (error) {
            return previousNow.then(function () {
              if (!disposed) {
                update(error);
              }
            });
          });
        });

        _this7.finish.attach(function () {
          previous.then(function () {
            if (!disposed) {
              finish();
            }
          });
        });

        return function () {
          disposed = true;

          _this7.dispose();
        };
      });
    }
  }, {
    key: "filter",
    value: function filter(fn) {
      var _this8 = this;

      return new Stream(function (update, finish) {
        _this8.values.attach(function (value) {
          if (fn(value)) {
            update(value);
          }
        });

        _this8.finish.attach(finish);

        return _this8.dispose;
      });
    }
  }, {
    key: "reduce",
    value: function reduce(fn, initial) {
      var _this9 = this;

      return new Promise(function (resolve) {
        var state = initial;

        var onValue = function onValue(value) {
          state = fn(state, value);
        };

        _this9.values.attach(onValue);

        _this9.finish.attach(function (nothing, detach) {
          resolve(state);
          detach();

          _this9.values.detach(onValue);
        });
      });
    }
  }]);

  return Stream;
}();

exports.Stream = Stream;

var StreamWithEnding =
/*#__PURE__*/
function () {
  function StreamWithEnding() {
    _classCallCheck(this, StreamWithEnding);
  }

  _createClass(StreamWithEnding, null, [{
    key: "fromStreamAndPromise",
    // ending never resolves before stream finishes
    value: function fromStreamAndPromise(s, ending) {
      // all these empty cathces
      // are to make node.js happy to stop showing stupid errors
      // on unhandled rejections
      ending["catch"](function () {});
      var res = new StreamWithEnding();
      res.stream = s;
      var def = (0, _deferred.deferred)();

      res.dispose = function (e) {
        def.reject(e);
        def.promise["catch"](function () {});
        s.dispose();
      };

      s.awaitFinish().then(function () {
        def.resolve();
      });
      res.ending = def.promise.then(function () {
        return ending;
      });
      res.ending["catch"](function () {});
      return res;
    }
  }, {
    key: "fromPromise",
    value: function fromPromise(p) {
      // $FlowIssue the error thing - flow cannot infer
      var res = new StreamWithEnding(); // the rejection will come to the ending promise
      // but if we use filterError, U can never include error

      var disposed = false;
      res.stream = Stream.fromPromise(p.then(function (s) {
        if (disposed) {
          throw new Error('disposed'); // will be ignored
        } else {
          return s.stream;
        }
      }), true);
      res.ending = p.then(function (s) {
        return s.ending;
      });
      res.ending["catch"](function () {});
      var resolved = null;
      p.then(function (s) {
        resolved = s;
      });

      res.dispose = function (e) {
        disposed = true;

        if (resolved != null) {
          resolved.dispose(e);
        }
      };

      return res;
    }
  }]);

  return StreamWithEnding;
}();

exports.StreamWithEnding = StreamWithEnding;