"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkerDiscovery = void 0;

var _utxoLib = require("@trezor/utxo-lib");

var _stream = require("../utils/stream");

var _outside = require("./worker/outside");

var _simpleWorkerChannel = require("../utils/simple-worker-channel");

var _addressSource = require("../address-source");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var WorkerDiscovery =
/*#__PURE__*/
function () {
  // eslint-disable-next-line no-undef
  function WorkerDiscovery( // eslint-disable-next-line no-undef
  discoveryWorkerFactory, // eslint-disable-next-line no-undef
  fastXpubWorker, fastXpubWasmPromise, chain) {
    var _this = this;

    _classCallCheck(this, WorkerDiscovery);

    _defineProperty(this, "forceAddedTransactions", []);

    _defineProperty(this, "forceAddedTransactionsEmitter", new _stream.Emitter());

    _defineProperty(this, "forceAddedTransactionsStream", _stream.Stream.fromEmitter(this.forceAddedTransactionsEmitter, function () {}).map(function () {
      return 'block';
    }));

    this.discoveryWorkerFactory = discoveryWorkerFactory; // $FlowIssue

    this.addressWorkerChannel = typeof WebAssembly === 'undefined' ? null : new _simpleWorkerChannel.WorkerChannel(fastXpubWorker);
    fastXpubWasmPromise.then(function (binary) {
      if (_this.addressWorkerChannel !== null) {
        fastXpubWorker.postMessage({
          type: 'init',
          binary: binary
        });
      }
    }, function (error) {
      return console.error(error);
    });
    this.chain = chain;
  } // this is used only for testing


  _createClass(WorkerDiscovery, [{
    key: "destroy",
    value: function destroy() {
      if (this.addressWorkerChannel != null) {
        this.addressWorkerChannel.destroy();
      }
    }
  }, {
    key: "forceAddTransaction",
    // useful for adding transactions right after succesful send
    value: function forceAddTransaction(transaction) {
      this.forceAddedTransactions.push(transaction);
      this.forceAddedTransactionsEmitter.emit(true);
    }
  }, {
    key: "discoverAccount",
    value: function discoverAccount(initial, xpub, network, segwit, cashAddress, gap, // what (new Date().getTimezoneOffset()) returns
    // note that it is NEGATIVE from the UTC string timezone
    // so, UTC+2 timezone returns -120...
    // it's javascript, it's insane by default
    timeOffset) {
      var _this2 = this;

      var node = tryHDNode(xpub, network);

      if (node instanceof Error) {
        return _stream.StreamWithEnding.fromStreamAndPromise(_stream.Stream.empty(), Promise.reject(node));
      }

      return _stream.StreamWithEnding.fromPromise(Promise.all([this.deriveXpub(xpub, network, 0), this.deriveXpub(xpub, network, 1)]).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            externalXpub = _ref2[0],
            internalXpub = _ref2[1];

        var internal = _utxoLib.HDNode.fromBase58(internalXpub, network, true);

        var external = _utxoLib.HDNode.fromBase58(externalXpub, network, true);

        var sources = [_this2.createWorkerAddressSource(external, network, segwit), _this2.createWorkerAddressSource(internal, network, segwit)];
        var out = new _outside.WorkerDiscoveryHandler(_this2.discoveryWorkerFactory, _this2.chain, sources, network, cashAddress || false, _this2.forceAddedTransactions);
        return out.discovery(initial, xpub, segwit === 'p2sh', gap, timeOffset);
      }));
    }
  }, {
    key: "monitorAccountActivity",
    value: function monitorAccountActivity(initial, xpub, network, segwit, cashAddress, gap, // what (new Date().getTimezoneOffset()) returns
    // note that it is NEGATIVE from the UTC string timezone
    // so, UTC+2 timezone returns -120...
    // it's javascript, it's insane by default
    timeOffset) {
      var _this3 = this;

      var node = tryHDNode(xpub, network);

      if (node instanceof Error) {
        return _stream.Stream.simple(node);
      }

      return _stream.Stream.fromPromise(Promise.all([this.deriveXpub(xpub, network, 0), this.deriveXpub(xpub, network, 1)]).then(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            externalXpub = _ref4[0],
            internalXpub = _ref4[1];

        var internal = _utxoLib.HDNode.fromBase58(internalXpub, network, true);

        var external = _utxoLib.HDNode.fromBase58(externalXpub, network, true);

        var sources = [_this3.createWorkerAddressSource(external, network, segwit), _this3.createWorkerAddressSource(internal, network, segwit)];

        function allAddresses(info) {
          if (info == null) {
            return new Set([]);
          }

          return new Set(info.usedAddresses.map(function (a) {
            return a.address;
          }).concat(info.unusedAddresses).concat(info.changeAddresses));
        }

        _this3.chain.subscribe(allAddresses(initial));

        var currentState = initial;

        var txNotifs = _this3.chain.notifications.filter(function (tx) {
          // determine if it's mine
          var addresses = allAddresses(currentState);
          var mine = false;
          tx.inputAddresses.concat(tx.outputAddresses).forEach(function (a) {
            if (a != null) {
              if (addresses.has(a)) {
                mine = true;
              }
            }
          });
          return mine;
        }).map(function (tx) {
          return tx;
        }); // flow thing
        // we need to do updates on blocks, if there are unconfs


        var blockStream = _this3.chain.blocks.map(function () {
          return 'block';
        });

        var reloads = _stream.Stream.combineFlat([blockStream, txNotifs, _this3.forceAddedTransactionsStream]);

        var res = reloads.mapPromise(function () {
          var out = new _outside.WorkerDiscoveryHandler(_this3.discoveryWorkerFactory, _this3.chain, sources, network, cashAddress || false, _this3.forceAddedTransactions);
          var discovery = out.discovery(currentState, xpub, segwit === 'p2sh', gap, timeOffset);
          var ending = discovery.ending;
          var pres = ending.then(function (eres) {
            currentState = eres;
            return eres;
          });
          return pres;
        });
        return res;
      }));
    }
  }, {
    key: "createWorkerAddressSource",
    value: function createWorkerAddressSource(node, network, segwit) {
      if (this.addressWorkerChannel == null) {
        return null;
      }

      var version = segwit === 'p2sh' ? network.scriptHash : network.pubKeyHash;
      return new _addressSource.WorkerAddressSource(this.addressWorkerChannel, node, version, segwit);
    }
  }, {
    key: "deriveXpub",
    value: function deriveXpub(xpub, network, index) {
      if (this.addressWorkerChannel == null) {
        return Promise.resolve(_utxoLib.HDNode.fromBase58(xpub, network, true).derive(index).toBase58());
      }

      return this.addressWorkerChannel.postMessage({
        type: 'deriveNode',
        xpub: xpub,
        version: network.bip32["public"],
        index: index
      }).then(function (x) {
        return x.xpub;
      });
    }
  }]);

  return WorkerDiscovery;
}();

exports.WorkerDiscovery = WorkerDiscovery;

function tryHDNode(xpub, network) {
  try {
    var node = _utxoLib.HDNode.fromBase58(xpub, network, true);

    if (!node.isNeutered()) {
      throw new Error('XPRV entrered instead of XPUB. Exiting.');
    }

    return node;
  } catch (e) {
    return e;
  }
}