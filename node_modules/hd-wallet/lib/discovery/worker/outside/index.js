"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkerDiscoveryHandler = void 0;

var _bchaddrjs = _interopRequireDefault(require("bchaddrjs"));

var _stream = require("../../../utils/stream");

var _channel = require("./channel");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var WorkerDiscoveryHandler =
/*#__PURE__*/
function () {
  // this array is the SAME object as in the WorkerDiscovery object
  // it will be changed here - this is intentional
  // we want to delete from this array if we actually see the tx in the wild
  function WorkerDiscoveryHandler(f, blockchain, addressSources, network, cashAddress, forceAddedTransactions) {
    var _this = this;

    _classCallCheck(this, WorkerDiscoveryHandler);

    _defineProperty(this, "forceAddedTransactions", []);

    _defineProperty(this, "counter", new TransactionCounter());

    this.blockchain = blockchain;
    this.addressSources = addressSources;
    this.workerChannel = new _channel.WorkerChannel(f, function (r) {
      return _this.getPromise(r);
    }, function (r) {
      return _this.getStream(r);
    });
    this.network = network;
    this.cashAddress = cashAddress;
    this.forceAddedTransactions = forceAddedTransactions;
  }

  _createClass(WorkerDiscoveryHandler, [{
    key: "discovery",
    value: function discovery(ai, xpub, segwit, gap, // what (new Date().getTimezoneOffset()) returns
    // note that it is NEGATIVE from the UTC string timezone
    // so, UTC+2 timezone returns -120...
    // it's javascript, it's insane by default
    timeOffset) {
      var _this2 = this;

      // $FlowIssue
      var webassembly = typeof WebAssembly !== 'undefined';
      this.workerChannel.postToWorker({
        type: 'init',
        state: ai,
        network: this.network,
        webassembly: webassembly,
        xpub: xpub,
        segwit: segwit,
        cashAddress: this.cashAddress,
        gap: gap,
        timeOffset: timeOffset
      });
      this.workerChannel.postToWorker({
        type: 'startDiscovery'
      });
      var promise = this.workerChannel.resPromise(function () {
        _this2.counter.finisher.emit();

        _this2.counter.stream.dispose();
      });

      var res = _stream.StreamWithEnding.fromStreamAndPromise(this.counter.stream, promise);

      return res;
    }
  }, {
    key: "getStream",
    value: function getStream(p) {
      if (p.type === 'chunkTransactions') {
        var source = this.addressSources[p.chainId];

        if (p.chainId === 0) {
          this.counter.setCount(p.pseudoCount);
        }

        return this.getChunkStream(source, p.firstIndex, p.lastIndex, p.startBlock, p.endBlock, p.chainId === 0, p.addresses);
      }

      return _stream.Stream.simple("Unknown request ".concat(p.type));
    }
  }, {
    key: "getPromise",
    value: function getPromise(p) {
      if (p.type === 'lookupBlockHash') {
        return this.blockchain.lookupBlockHash(p.height);
      }

      if (p.type === 'lookupSyncStatus') {
        return this.blockchain.lookupSyncStatus().then(function (_ref) {
          var height = _ref.height;
          return height;
        });
      }

      if (p.type === 'doesTransactionExist') {
        return this.blockchain.lookupTransaction(p.txid).then(function () {
          return true;
        }, function () {
          return false;
        });
      }

      return Promise.reject(new Error("Unknown request ".concat(p.type)));
    }
  }, {
    key: "getChunkStream",
    value: function getChunkStream(source, firstIndex, lastIndex, startBlock, endBlock, add, oaddresses) {
      var _this3 = this;

      var addressPromise = WorkerDiscoveryHandler.deriveAddresses(source, oaddresses, firstIndex, lastIndex);

      var errStream = _stream.Stream.fromPromise(addressPromise.then(function (paddresses) {
        var addresses = _this3.cashAddress ? paddresses.map(function (a) {
          return _bchaddrjs["default"].toCashAddress(a);
        }) : paddresses;
        return _this3.blockchain.lookupTransactionsStream(addresses, endBlock, startBlock).map(function (transactions) {
          if (transactions instanceof Error) {
            return transactions.message;
          }

          var transactions_ = transactions; // code for handling forceAdded transactions

          var addedTransactions = [];

          _this3.forceAddedTransactions.slice().forEach(function (transaction, i) {
            var transaction_ = _objectSpread({}, transaction, {
              height: null,
              timestamp: null
            });

            if (transactions_.map(function (t) {
              return t.hash;
            }).some(function (hash) {
              return transaction.hash === hash;
            })) {
              // transaction already came from blockchain again
              _this3.forceAddedTransactions.splice(i, 1);
            } else {
              var txAddresses = new Set();
              transaction.inputAddresses.concat(transaction.outputAddresses).forEach(function (a) {
                if (a != null) {
                  txAddresses.add(a);
                }
              });

              if (addresses.some(function (address) {
                return txAddresses.has(address);
              })) {
                addedTransactions.push(transaction_);
              }
            }
          });

          _this3.counter.setCount(_this3.counter.count + transactions.length);

          var ci = {
            transactions: transactions.concat(addedTransactions),
            addresses: addresses
          };
          return ci;
        });
      }));

      var resStream = errStream.map(function (k) {
        if (k instanceof Error) {
          return k.message;
        }

        return k;
      });
      return resStream;
    }
  }], [{
    key: "deriveAddresses",
    value: function deriveAddresses(source, addresses, firstIndex, lastIndex) {
      if (addresses == null) {
        if (source == null) {
          return Promise.reject(new Error('Cannot derive addresses in worker without webassembly'));
        }

        return source.derive(firstIndex, lastIndex);
      }

      return Promise.resolve(addresses);
    }
  }]);

  return WorkerDiscoveryHandler;
}();

exports.WorkerDiscoveryHandler = WorkerDiscoveryHandler;

var TransactionCounter =
/*#__PURE__*/
function () {
  function TransactionCounter() {
    _classCallCheck(this, TransactionCounter);

    _defineProperty(this, "count", 0);

    _defineProperty(this, "emitter", new _stream.Emitter());

    _defineProperty(this, "finisher", new _stream.Emitter());

    _defineProperty(this, "stream", _stream.Stream.fromEmitterFinish(this.emitter, this.finisher, function () {}));
  }

  _createClass(TransactionCounter, [{
    key: "setCount",
    value: function setCount(i) {
      if (i > this.count) {
        this.count = i;
        this.emitter.emit({
          transactions: this.count
        });
      }
    }
  }]);

  return TransactionCounter;
}();