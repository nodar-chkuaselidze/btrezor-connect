"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkerChannel = void 0;

var _queue = _interopRequireDefault(require("queue"));

var _stream = require("../../../utils/stream");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var CONCURRENT_WORKERS = 4;
var q = (0, _queue["default"])({
  concurrency: CONCURRENT_WORKERS,
  autostart: true
});

var WorkerChannel =
/*#__PURE__*/
function () {
  // eslint-disable-next-line no-undef
  function WorkerChannel(f, getPromise, getStream) {
    var _this = this;

    _classCallCheck(this, WorkerChannel);

    _defineProperty(this, "messageEmitter", new _stream.Emitter());

    this.getPromise = getPromise;
    this.getStream = getStream;
    this.w = new Promise(function (resolve) {
      q.push(function (cb) {
        var worker = f();
        var finish = cb; // $FlowIssue

        worker.onmessage = function (event) {
          // eslint-disable-next-line
          var data = event.data;

          _this.messageEmitter.emit(data);
        };

        resolve({
          worker: worker,
          finish: finish
        });
      });
    });
    this.messageEmitter.attach(function (message) {
      if (message.type === 'promiseRequest') {
        _this.handlePromiseRequest(message);
      }

      if (message.type === 'streamRequest') {
        _this.handleStreamRequest(message);
      }
    });
  }

  _createClass(WorkerChannel, [{
    key: "postToWorker",
    value: function postToWorker(m) {
      this.w.then(function (w) {
        w.worker.postMessage(m);
      });
    }
  }, {
    key: "resPromise",
    value: function resPromise(onFinish) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2.messageEmitter.attach(function (message, detach) {
          if (message.type === 'result') {
            resolve(message.result);
            detach();
            onFinish();

            _this2.w.then(function (w) {
              w.worker.terminate();
              w.finish();
            });
          }

          if (message.type === 'error') {
            reject(new Error(message.error));
            detach();
            onFinish();

            _this2.w.then(function (w) {
              w.worker.terminate();
              w.finish();
            });
          }
        });
      });
    }
  }, {
    key: "handlePromiseRequest",
    value: function handlePromiseRequest(request) {
      var _this3 = this;

      var promise = this.getPromise(request.request);
      promise.then(function (result) {
        // $FlowIssue I overload Flow logic a bit here
        var r = {
          type: request.request.type,
          response: result
        };

        _this3.postToWorker({
          type: 'promiseResponseSuccess',
          id: request.id,
          response: r
        });
      }, function (error) {
        var message = error.message == null ? error.toString() : error.message.toString();

        _this3.postToWorker({
          type: 'promiseResponseFailure',
          failure: message,
          id: request.id
        });
      });
    }
  }, {
    key: "handleStreamRequest",
    value: function handleStreamRequest(request) {
      var _this4 = this;

      var stream = this.getStream(request.request);
      stream.values.attach(function (value) {
        _this4.postToWorker({
          type: 'streamResponseUpdate',
          id: request.id,
          update: {
            type: request.request.type,
            response: value
          }
        });
      });
      stream.finish.attach(function () {
        _this4.postToWorker({
          type: 'streamResponseFinish',
          id: request.id
        });
      });
    }
  }]);

  return WorkerChannel;
}();

exports.WorkerChannel = WorkerChannel;