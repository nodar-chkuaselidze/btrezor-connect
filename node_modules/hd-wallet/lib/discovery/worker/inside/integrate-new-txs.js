"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.integrateNewTxs = integrateNewTxs;

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _deriveUtxos = require("./derive-utxos");

var _deriveAnalysis = require("./derive-analysis");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// When utxo transaction disappear, so does the utxo
// However, if it was transaction from us, it also means
// utxo has to be added (if it is a tx that came from us)
//
// If the utxo that needs to be added is in the new info
// - as is in the case when it is a chain of unconf txs -
// it will be readded again in derive-utxos
//
// However, if it is an old tx, it needs to be added here
// because derive-utxos does not go through old txs
function deleteTxs(oldInfo, txs, atp) {
  var set = new Set(txs);
  var filteredUtxos = oldInfo.utxos.filter(function (utxo) {
    return !set.has(utxo.transactionHash);
  });
  var deletedTransactions = oldInfo.transactions.filter(function (tx) {
    return set.has(tx.hash);
  });
  var filteredTransactions = oldInfo.transactions.filter(function (tx) {
    return !set.has(tx.hash);
  });
  var addedUtxos = [];
  deletedTransactions.forEach(function (deletedTran) {
    // this is not efficient At ALL,
    // but it does not happen frequently
    // (usually not at all)
    // => no need to optimize here, just go naively
    deletedTran.inputs.forEach(function (deletedInp) {
      var deletedInpHash = deletedInp.id;
      var deletedInpI = deletedInp.index;
      filteredTransactions.forEach(function (transaction) {
        var thash = transaction.hash;

        if (thash === deletedInpHash) {
          var o = transaction.myOutputs[deletedInpI];

          if (o != null) {
            // ALSO needs to find, if any of the inputs
            // are also mine
            var own = false;
            filteredTransactions.forEach(function (ptran) {
              transaction.inputs.forEach(function (ip) {
                if (ip.id === ptran.hash && ptran.myOutputs[ip.index] != null) {
                  own = true;
                }
              });
            });
            addedUtxos.push(utxoFromTarget(o, transaction, atp, own));
          }
        }
      });
    });
  });
  return _objectSpread({}, oldInfo, {
    utxos: filteredUtxos.concat(addedUtxos),
    transactions: filteredTransactions
  });
}

function utxoFromTarget(t, tx, atp, own) {
  var resIx = {
    index: t.i,
    value: t.value,
    transactionHash: tx.hash,
    height: tx.height,
    coinbase: tx.isCoinbase,
    addressPath: atp[t.address],
    vsize: tx.vsize,
    tsize: tx.tsize,
    own: own
  };
  return resIx;
}

function integrateNewTxs(newInfo, oldInfoUndeleted, lastBlock, deletedTxs, gap, wantedOffset) {
  var addressToPath = deriveAddressToPath(newInfo.main.allAddresses, newInfo.change.allAddresses);
  var oldInfo = deletedTxs.length !== 0 ? deleteTxs(oldInfoUndeleted, deletedTxs, addressToPath) : oldInfoUndeleted;
  var joined = deriveJoined(newInfo.main.newTransactions, newInfo.change.newTransactions);
  var utxos = (0, _deriveUtxos.deriveUtxos)(newInfo, oldInfo, addressToPath, joined);
  var transactions = (0, _deriveAnalysis.deriveAnalysis)(joined, oldInfo.transactions, addressToPath, lastBlock, wantedOffset);

  var _deriveUsedAddresses = deriveUsedAddresses(transactions, addressToPath, newInfo.main.allAddresses, 0, gap),
      usedAddresses = _deriveUsedAddresses.usedAddresses,
      unusedAddresses = _deriveUsedAddresses.unusedAddresses,
      lastConfirmedMain = _deriveUsedAddresses.lastConfirmed;

  var usedChange = deriveUsedAddresses(transactions, addressToPath, newInfo.change.allAddresses, 1, gap);
  var balance = transactions.length > 0 ? transactions[0].balance : '0';
  var utxoBalance = utxos.reduce(function (prev, a) {
    return new _bignumber["default"](a.value).plus(prev);
  }, new _bignumber["default"](0)).toString();

  if (balance !== utxoBalance) {
    throw new Error('Inconsistent info.');
  }

  var sentAddresses = deriveSentAddresses(transactions);
  var changeAddresses = newInfo.change.allAddresses;
  var changeIndex = usedChange.usedAddresses.length;
  var allowChange = usedChange.unusedAddresses.length > 0;
  var lastConfirmedChange = usedChange.lastConfirmed;
  var state = {
    utxos: utxos,
    transactions: transactions,
    usedAddresses: usedAddresses,
    unusedAddresses: unusedAddresses,
    lastConfirmedMain: lastConfirmedMain,
    lastConfirmedChange: lastConfirmedChange,
    changeIndex: changeIndex,
    balance: balance,
    lastBlock: lastBlock,
    sentAddresses: sentAddresses,
    changeAddresses: changeAddresses,
    allowChange: allowChange,
    version: oldInfoUndeleted.version
  };
  return state;
}

function deriveAddressToPath(main, change) {
  var res = {};
  main.forEach(function (a, i) {
    res[a] = [0, i];
  });
  change.forEach(function (a, i) {
    res[a] = [1, i];
  });
  return res;
}

function deriveJoined(main, change) {
  var res = {};
  Object.keys(main).forEach(function (id) {
    res[id] = main[id];
  });
  Object.keys(change).forEach(function (id) {
    res[id] = change[id];
  });
  return res;
}

function deriveSentAddresses(transactions) {
  var res = {};
  transactions.forEach(function (t) {
    if (t.type === 'sent') {
      t.targets.forEach(function (_ref) {
        var address = _ref.address,
            i = _ref.i;
        var txId = t.hash;
        var key = "".concat(txId, ":").concat(i);
        res[key] = address;
      });
    }
  });
  return res;
}

function deriveUsedAddresses(transactions, addressToPath, allAddresses, chain, gap) {
  var allReceived = [];
  var lastUsed = -1;
  var lastConfirmed = -1;
  transactions.forEach(function (t) {
    (0, _utils.objectValues)(t.myOutputs).forEach(function (_ref2) {
      var address = _ref2.address,
          value = _ref2.value;
      var path = addressToPath[address];

      if (path[0] === chain) {
        var id = path[1];

        if (allReceived[id] == null) {
          allReceived[id] = value;
        } else {
          allReceived[id] = new _bignumber["default"](allReceived[id]).plus(new _bignumber["default"](value)).toString();
        }

        if (lastUsed < id) {
          lastUsed = id;
        }

        if (t.height != null) {
          if (lastConfirmed < id) {
            lastConfirmed = id;
          }
        }
      }
    });
  });
  var usedAddresses = [];

  for (var i = 0; i <= lastUsed; i++) {
    var address = allAddresses[i];
    var received = allReceived[i] == null ? '0' : allReceived[i];
    usedAddresses.push({
      address: address,
      received: received
    });
  }

  var unusedAddresses = [];

  for (var _i = lastUsed + 1; _i <= lastConfirmed + gap; _i++) {
    unusedAddresses.push(allAddresses[_i]);
  }

  return {
    usedAddresses: usedAddresses,
    unusedAddresses: unusedAddresses,
    lastConfirmed: lastConfirmed
  };
}