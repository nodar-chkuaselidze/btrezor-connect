"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GetChainTransactions = void 0;

var _utxoLib = require("@trezor/utxo-lib");

var _bchaddrjs = _interopRequireDefault(require("bchaddrjs"));

var _deferred = require("../../../utils/deferred");

var _stream = require("../../../utils/stream");

var _addressSource = require("../../../address-source");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// request Transaction values as strings
_utxoLib.Transaction.USE_STRING_VALUES = true;

var GetChainTransactions =
/*#__PURE__*/
function () {
  _createClass(GetChainTransactions, [{
    key: "originalLastSearched",
    // all seen addresses, including the gap addresses
    // address -> number map
    // transactions in the range will be saved to this array
    // indexed by hash
    // path of last address that I searched
    // last address that was searched with the previous search
    value: function originalLastSearched() {
      return this.originalLastConfirmed + this.gap;
    } // this is deferred promise for result

  }, {
    key: "nullRange",
    value: function nullRange() {
      return {
        firstHeight: 0,
        last: this.range.last
      };
    }
  }]);

  function GetChainTransactions(id, range, originalLastConfirmed, getStream, originalTransactions, oldAddresses, network, xpub, segwit, webassembly, cashAddress, gap) {
    _classCallCheck(this, GetChainTransactions);

    _defineProperty(this, "allCheckedAddresses", []);

    _defineProperty(this, "backSearch", {});

    _defineProperty(this, "newTransactions", {});

    _defineProperty(this, "lastSearched", -1);

    _defineProperty(this, "dfd", (0, _deferred.deferred)());

    this.gap = gap;
    this.cashAddress = cashAddress;
    this.originalLastConfirmed = originalLastConfirmed;
    this.lastConfirmed = originalLastConfirmed;
    this.chainId = id;
    this.range = range;
    this.getStream = getStream;
    this.txids = deriveTxidSet(originalTransactions);
    this.allAddresses = oldAddresses;
    this.network = network;
    this.xpub = xpub;
    this.segwit = segwit;
    this.webassembly = webassembly;

    if (!this.webassembly) {
      this.source = new _addressSource.BrowserAddressSource(_utxoLib.HDNode.fromBase58(this.xpub, this.network).derive(this.chainId), this.network, this.segwit);
    }
  }

  _createClass(GetChainTransactions, [{
    key: "discover",
    value: function discover() {
      // first and last range of addresses for the first search
      // (always 0 - 19)
      var first = 0;
      var last = this.gap - 1;
      this.iterate(first, last, this.range);
      return this.dfd.promise;
    } // one "iteration" - meaning, get stream of transactions on one chunk,
    // wait for it to end, and then decide what to do next

  }, {
    key: "iterate",
    value: function iterate(first, last, // last is inclusive
    range) {
      var _this = this;

      var addressesP = Promise.resolve(null);

      if (this.allAddresses.length - 1 >= last) {
        addressesP = Promise.resolve(this.allAddresses.slice(first, last + 1));
      } else if (!this.webassembly) {
        addressesP = this.source.derive(first, last);
      }

      addressesP.then(function (addresses) {
        var stream = _this.getStream(_this.chainId, first, last, range.firstHeight, range.last.height, _this.txids.size, addresses);

        stream.values.attach(function (value_) {
          if (value_ instanceof Error) {
            _this.dfd.reject(value_);

            stream.dispose();
            return;
          }

          var value = value_;

          try {
            _this.handleTransactions(value, first);
          } catch (error) {
            _this.dfd.reject(new Error("Error transaction parsing: ".concat(error.message || error.toString())));

            stream.dispose();
          }
        });
        stream.finish.attach(function () {
          _this.handleFinish(last);
        });
      });
    } // What to do with transactions?

  }, {
    key: "handleTransactions",
    value: function handleTransactions(value, first) {
      var _this2 = this;

      // save the addresses
      value.addresses.forEach(function (address, i) {
        _this2.allAddresses[i + first] = address;
        _this2.allCheckedAddresses[i + first] = address;
        _this2.backSearch[address] = i + first;
      });
      value.transactions.forEach(function (transaction) {
        // parse txs (error in here is handled in iterate)
        var parsed;
        var invalidTransaction = false;

        try {
          parsed = _utxoLib.Transaction.fromHex(transaction.hex, transaction.network);
        } catch (error) {
          // create invalid transaction with zero-valued outputs
          invalidTransaction = true;
          parsed = new _utxoLib.Transaction();

          if (transaction.rawTx) {
            parsed.outs = transaction.rawTx.outputs.map(function (out) {
              return {
                script: Buffer.from(out.script, 'hex'),
                value: '0'
              };
            });
          }
        }

        var outputAddresses = [];
        parsed.outs.forEach(function (output) {
          var address; // try-catch, because some outputs don't have addresses

          try {
            address = _utxoLib.address.fromOutputScript(output.script, _this2.network);

            if (_this2.cashAddress) {
              address = _bchaddrjs["default"].toCashAddress(address);
            } // if mine...


            if (_this2.backSearch[address] != null) {
              // check if confirmed
              if (transaction.height != null) {
                var _addressI = _this2.backSearch[address]; // if it's mine and confirmed, bump lastConfirmed

                if (_addressI > _this2.lastConfirmed) {
                  _this2.lastConfirmed = _addressI;
                }
              }
            }
          } catch (e) {
            // TODO add to flowdef
            // $FlowIssue
            var type = _utxoLib.script.classifyOutput(output.script);

            if (type === 'nulldata') {
              var buffer = _utxoLib.script.nullData.output.decode(output.script);

              var text = '';

              if (buffer !== 0) {
                if (buffer.every(function (i) {
                  return i >= 32 && i <= 126;
                })) {
                  var ascii = buffer.toString('ascii');
                  text = ascii.slice(0, 40);
                } else {
                  var hex = "0x".concat(buffer.toString('hex'));
                  text = hex.slice(0, 40);
                }
              }

              address = "OP_RETURN (".concat(text, ")");
            } else {
              address = 'UNKNOWN';
            }
          }

          outputAddresses.push(address);
        });
        var c = {
          tx: parsed,
          invalidTransaction: invalidTransaction,
          outputAddresses: outputAddresses,
          height: transaction.height,
          timestamp: transaction.timestamp,
          hash: transaction.hash,
          vsize: transaction.vsize,
          inputAddresses: transaction.inputAddresses
        }; // more transactions with the same ID overwrite each other

        _this2.newTransactions[c.hash] = c;

        _this2.txids.add(c.hash);
      });
    } // when stream finishes, we have to decide if we want try more addresses or not

  }, {
    key: "handleFinish",
    value: function handleFinish(last) {
      this.lastSearched = last; // look at which is the next thing we want

      var shouldSearchLast = this.lastConfirmed + this.gap;
      var nextChunkEnd = this.lastSearched + this.gap;
      var nextLast = shouldSearchLast < nextChunkEnd ? shouldSearchLast : nextChunkEnd;
      var nextFirst = this.lastSearched + 1; // Is there something to search?

      if (nextLast >= nextFirst) {
        // on completely new addresses, we look from block 0
        // so we don't miss transactions
        // are there some new addresses?
        if (nextLast > this.originalLastSearched()) {
          // new addresses, all blocks
          this.iterate(nextFirst, nextLast, this.nullRange());
        } else {
          // old addresses, just new blocks
          this.iterate(nextFirst, nextLast, this.range);
        }
      } else {
        // nothing more to look for, return
        this.dfd.resolve({
          newTransactions: this.newTransactions,
          allAddresses: this.allAddresses
        });
      }
    }
  }]);

  return GetChainTransactions;
}();

exports.GetChainTransactions = GetChainTransactions;

function deriveTxidSet(transactions) {
  var res = new Set();
  transactions.forEach(function (t) {
    res.add(t.hash);
  });
  return res;
}