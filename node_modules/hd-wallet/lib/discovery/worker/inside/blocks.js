"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadBlockRange = loadBlockRange;

var _channel = require("./channel");

// Some helper functions for loading block status
// from blockchain
// from which to which block do I need to do discovery
// based on whether there was a reorg, detected by last height/hash
function loadBlockRange(initialState) {
  var pBlock = initialState.lastBlock; // first, I ask for last block I will do

  return getCurrentBlock().then(function (last) {
    // then I detect first block I will do
    // detect based on whether reorg is needed
    // I do not do reorgs inteligently, I always discard all
    var firstHeight = pBlock.height !== 0 ? getBlock(pBlock.height).then(function (block) {
      if (block.hash === pBlock.hash) {
        return pBlock.height;
      }

      console.warn('Blockhash mismatch', pBlock, block);
      return 0;
    }, function (err) {
      if (err.message === 'RPCError: Block height out of range') {
        console.warn('Block height out of range', pBlock.height);
        return 0;
      }

      throw err;
    }) : Promise.resolve(0);
    return firstHeight.then(function (h) {
      return {
        firstHeight: h,
        last: last
      };
    });
  });
}

function getBlock(height) {
  return (0, _channel.lookupBlockHash)(height).then(function (hash) {
    return {
      hash: hash,
      height: height
    };
  });
}

function getCurrentBlock() {
  return (0, _channel.lookupSyncStatus)().then(function (height) {
    return getBlock(height);
  });
}