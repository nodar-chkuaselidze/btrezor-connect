"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deriveUtxos = deriveUtxos;

var _utxoLib = require("@trezor/utxo-lib");

var _utils = require("../utils");

// what is hapenning here:
// I have a state with old utxo set
// and some new transactions
// and the only thing that can happen is that new utxos arrive
// from the new transactions, or the old utxos are spent
// The way this is done, no new utxos are added "back"
// from the old transactions.
// This is to save time - we do not need to go through old
// transactions, just through the new ones
//
// Note that this on itself could cause a problem
// If there is outgoing transaction in a mempool in the old state
// that is later removed,
// old utxos need to be added;
// I find such old utxos in index.js in findDeleted
// and later pass them here
function deriveUtxos(newInfo, oldInfo, addressToPath, joined) {
  // First do preparations
  // Make set of all my transaction IDs, old and new
  var allTransactionHashes = deriveAllTransactionHashes(newInfo.main.newTransactions, newInfo.change.newTransactions, oldInfo.transactions); // Then, make set of spent outputs
  // (tx + ":" + id)

  var spentOutputs = deriveSpentOutputs(allTransactionHashes, newInfo.main.newTransactions, newInfo.change.newTransactions, oldInfo.transactions); // actual logic

  var utxos = _deriveUtxos(oldInfo.utxos, joined, addressToPath, spentOutputs);

  return utxos;
}

function deriveAllTransactionHashes(main, change, old) {
  var res = new Set();
  Object.keys(main).forEach(function (id) {
    res.add(id);
  });
  Object.keys(change).forEach(function (id) {
    res.add(id);
  });
  old.forEach(function (t) {
    res.add(t.hash);
  });
  return res;
}

function deriveSpentOutputs(allTransactionHashes, main, change, old) {
  var res = new Set(); // saving only mine spent outputs
  // (to save some time)

  function canTxBeMine(id) {
    return allTransactionHashes.has(id);
  }

  function saveNew(ts) {
    (0, _utils.objectValues)(ts).forEach(function (tx) {
      tx.tx.ins.forEach(function (inp) {
        var i = inp.index;
        var id = (0, _utils.getInputId)(inp);

        if (canTxBeMine(id)) {
          res.add("".concat(id, ":").concat(i));
        }
      });
    });
  }

  old.forEach(function (t) {
    t.inputs.forEach(function (_ref) {
      var id = _ref.id,
          index = _ref.index;

      if (canTxBeMine(id)) {
        res.add("".concat(id, ":").concat(index));
      }
    });
  });
  saveNew(main);
  saveNew(change);
  return res;
}

function _deriveUtxos(currentUtxos, newTransactions, addressToPath, spentOutputs) {
  var res = {};

  var isOwnAddress = function isOwnAddress(address) {
    return address != null && addressToPath[address] != null;
  };

  var isCoinbase = function isCoinbase(tx) {
    return tx.ins.some(function (i) {
      return _utxoLib.Transaction.isCoinbaseHash(i.hash);
    });
  }; // first, delete spent utxos from current batch from staying


  var filteredUtxos = currentUtxos.filter(function (utxo) {
    var ix = "".concat(utxo.transactionHash, ":").concat(utxo.index);
    return !spentOutputs.has(ix);
  }); // second, add them to hash, so if there is new and confirmed utxo,
  // it will overwrite existing utxo

  filteredUtxos.forEach(function (utxo) {
    var ix = "".concat(utxo.transactionHash, ":").concat(utxo.index);
    res[ix] = utxo;
  }); // third, find utxos in new txs and maybe overwrite existing

  var newTxs = (0, _utils.objectValues)(newTransactions);
  newTxs.forEach(function (_ref2) {
    var hash = _ref2.hash,
        tx = _ref2.tx,
        height = _ref2.height,
        outputAddresses = _ref2.outputAddresses,
        inputAddresses = _ref2.inputAddresses,
        vsize = _ref2.vsize;
    var coinbase = isCoinbase(tx);
    var own = inputAddresses.some(function (address) {
      return isOwnAddress(address);
    });
    tx.outs.forEach(function (o, index) {
      var ix = "".concat(hash, ":").concat(index);
      var address = outputAddresses[index];

      if (spentOutputs.has(ix) || !isOwnAddress(address)) {
        return;
      }

      var addressPath = addressToPath[address];
      var resIx = {
        index: index,
        value: typeof o.value === 'string' ? o.value : o.value.toString(),
        transactionHash: hash,
        height: height,
        coinbase: coinbase,
        addressPath: addressPath,
        vsize: vsize,
        tsize: tx.byteLength(),
        own: own
      };
      res[ix] = resIx;
    });
  });
  return (0, _utils.objectValues)(res);
}