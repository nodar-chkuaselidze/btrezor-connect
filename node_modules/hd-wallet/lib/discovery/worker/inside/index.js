"use strict";

var channel = _interopRequireWildcard(require("./channel"));

var _blocks = require("./blocks");

var _dates = require("./dates");

var _getChainTransactions = require("./get-chain-transactions");

var _integrateNewTxs = require("./integrate-new-txs");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

// This is the entry to the worker, doing account discovery + analysis
// increase version for forced redownload of txs
// (on either format change, or on some widespread data corruption)
//
// version 1 added infos about fees and sizes; we cannot calculate that
// version 2 was correction in mytrezor
// v3 added info, whether utxo is my own or not
// so we have to re-download everything -> setting initial state as if nothing is known
// v4 changed timestamp format
// v5 is just to force re-download on forceAdded data corruption
// v6 changed types (tx amounts/values, fee, balance ect) from number to string
//      across the whole library (discovery and buildtx)
var LATEST_VERSION = 6; // Default starting info being used, when there is null

var defaultInfo = {
  utxos: [],
  transactions: [],
  usedAddresses: [],
  unusedAddresses: [],
  changeIndex: 0,
  balance: '0',
  sentAddresses: {},
  lastBlock: {
    height: 0,
    hash: 'abcd'
  },
  transactionHashes: {},
  changeAddresses: [],
  allowChange: false,
  lastConfirmedChange: -1,
  lastConfirmedMain: -1,
  version: LATEST_VERSION
};
var recvInfo;
var recvNetwork;
var recvXpub;
var recvSegwit;
var recvWebAssembly;
var recvGap;
var recvCashAddress; // what (new Date().getTimezoneOffset()) returns
// note that it is NEGATIVE from the UTC string timezone
// so, UTC+2 timezone returns -120...
// it's javascript, it's insane by default

var recvTimeOffset; // init on worker start

channel.initPromise.then(function (_ref) {
  var accountInfo = _ref.accountInfo,
      network = _ref.network,
      xpub = _ref.xpub,
      segwit = _ref.segwit,
      webassembly = _ref.webassembly,
      cashAddress = _ref.cashAddress,
      gap = _ref.gap,
      timeOffset = _ref.timeOffset;
  recvInfo = accountInfo;
  recvNetwork = network;
  recvSegwit = segwit;
  recvXpub = xpub;
  recvWebAssembly = webassembly;
  recvCashAddress = cashAddress;
  recvGap = gap;
  recvTimeOffset = timeOffset;
});
channel.startDiscoveryPromise.then(function () {
  var initialState = recvInfo == null ? defaultInfo : recvInfo;

  if (initialState.version == null || initialState.version < LATEST_VERSION) {
    initialState = defaultInfo;
  }

  (0, _dates.recomputeDateFormats)(initialState.transactions, recvTimeOffset); // first load blocks, then count last used indexes,
  // then start asking for new transactions,
  // then integrate new transactions into old transactions

  (0, _blocks.loadBlockRange)(initialState).then(function (range) {
    // when starting from 0, take as if there is no info
    var oldState = range.firstHeight === 0 ? defaultInfo : initialState;
    var changeAddresses = oldState.changeAddresses,
        lastConfirmedMain = oldState.lastConfirmedMain,
        lastConfirmedChange = oldState.lastConfirmedChange;
    var unconfirmedTxids = oldState.transactions.filter(function (t) {
      return t.height == null;
    }).map(function (t) {
      return t.hash;
    });
    var mainAddresses = oldState.usedAddresses.map(function (a) {
      return a.address;
    }).concat(oldState.unusedAddresses); // get all the new info, then...

    return discoverAccount(range, [lastConfirmedMain, lastConfirmedChange], oldState.transactions, mainAddresses, changeAddresses).then(function (newInfo) {
      // then find out deleted info
      var deleted = findDeleted(unconfirmedTxids, newInfo); // ... then integrate

      var res = (0, _integrateNewTxs.integrateNewTxs)(newInfo, oldState, range.last, deleted, recvGap, recvTimeOffset);
      return res;
    });
  }).then( // either success or failure
  // (other side will shut down the worker then)
  function (result) {
    return channel.returnSuccess(result);
  }, function (error) {
    return channel.returnError(error);
  });
});

function discoverAccount(range, lastUsedAddresses, transactions, mainAddresses, changeAddresses) {
  function d(i) {
    return new _getChainTransactions.GetChainTransactions(i, range, lastUsedAddresses[i], channel.chunkTransactions, i === 0 ? transactions : [], // used for visual counting
    i === 0 ? mainAddresses : changeAddresses, recvNetwork, recvXpub, recvSegwit, recvWebAssembly, recvCashAddress, recvGap).discover();
  }

  return d(0).then(function (main) {
    return d(1).then(function (change) {
      return {
        main: main,
        change: change
      };
    });
  });
}

function findDeleted(txids, newInfo) {
  return txids.filter(function (id) {
    if (newInfo.main.newTransactions[id] != null) {
      return false;
    }

    if (newInfo.change.newTransactions[id] != null) {
      return false;
    }

    return true;
  });
}